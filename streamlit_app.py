import streamlit as st
import pandas as pd
import os
import openai
from langchain_community.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.chains import LLMChain
from langchain.chains import SequentialChain
from dotenv import load_dotenv, find_dotenv
from datetime import datetime
from newsdataapi import NewsDataApiClient
from elevenlabs import play
from elevenlabs.client import ElevenLabs
import time
_ = load_dotenv(find_dotenv()) # read local .env file
elabs_api_key = st.secrets["ELABS_API_KEY"]
os.environ["ELABS_API_KEY"] = elabs_api_key
client = ElevenLabs(api_key = elabs_api_key)
newsdata_api_key = st.secrets["NEWS_API_KEY"]

api = NewsDataApiClient(apikey=newsdata_api_key)
st.header("Daily Bread Reflection")

#Retrieve bible passage
today = datetime.today()
apidate = today.strftime("%Y-%m-%d")
url = "https://github.com/surjadhanaAristo/DailyBreadReflection/blob/main/new.csv?raw=true"
df = pd.read_csv(url, index_col=0)
new_date = df[apidate][0]
gospel = st.text("")
content = st.text("")
story = st.markdown("")
image = st.text("")
reflection = st.text("")
ad = st.text("")

#establish key from secrets and environment variables
chatgpt_api_key = st.secrets["OPENAI_API_KEY"]
os.environ["OPENAI_API_KEY"] = chatgpt_api_key

if st.button("generate daily story"):
    #get news 
    def get_news_with_retry(api, retries=5):
        for i in range(retries):
            try:
                response = api.news_api(country="ca", category="top", language="en")
                return response
            except Exception as e:
                if i < retries - 1 and 'RateLimitExceeded' in str(e):
                    time.sleep(60 * (i + 1))  # Exponential backoff
                else:
                    raise
    response = get_news_with_retry(api)
    PROMPT = response["results"][0]["title"]
    content = response["results"][0]["description"]

    #establish llm
    llm = ChatOpenAI(temperature=0.9, openai_api_key=chatgpt_api_key)

    openai.api_key = chatgpt_api_key


    #st.image(image["data"][0]["url"])

    def get_completion(prompt, model="gpt-3.5-turbo", temperature=0):
        retries = 5
        for i in range(retries):
            try:
                messages = [{"role": "user", "content": prompt}]
                response = openai.ChatCompletion.create(
                    model=model,
                    messages=messages,
                    temperature=temperature,
                )
                return response.choices[0].message["content"]
            except openai.error.RateLimitError:
                if i < retries - 1:
                    time.sleep(60 * (i + 1))  # Exponential backoff
                else:
                    raise

    today_date = datetime.today().strftime('%m-%d')
    #chains

    first_prompt = ChatPromptTemplate.from_template(
    "Create a new short story less than 2000 characters, based on the daily gospel reading {new_date} with the news description: {content}"
    )
    chain_one = LLMChain(llm=llm, prompt=first_prompt,
                        output_key="new_story"
                        )


    second_prompt = ChatPromptTemplate.from_template(
    "Write a reflection on {new_story} within 6 sentences and make sure to create a newline after every sentence"
    )

    # chain 2
    chain_two = LLMChain(llm=llm, prompt=second_prompt,
                        output_key="reflection"
                        )


    third_prompt = ChatPromptTemplate.from_template(
        "Write a short prompt within 200 characters that will accurately portray the following story into an image generated by openai: {reflection}"
    )
    chain_three = LLMChain(llm=llm, prompt=third_prompt,
                        output_key="image")

    overall_chain = SequentialChain(
        chains=[chain_one, chain_two, chain_three],
        input_variables=["new_date", "content"],
        output_variables=["new_story", "reflection", "image"],
        verbose=True
    )
    stories = overall_chain({"new_date":new_date, "content":content})

    image = openai.Image.create(
        prompt=stories["image"],
        n=1,
        size="256x256",
    )
    audio = client.generate(
        text=stories["reflection"],
        voice="Clyde",
        model='eleven_multilingual_v1'
    )
    gospel = st.text("gospel reading: " + new_date)
    content = st.text("news content: " + content)
    story = st.markdown("Generated story: " + stories["new_story"])
    image = st.image(image["data"][0]["url"])
    reflection = st.markdown(stories["reflection"])
    audio_bytes = b''.join(audio)

    ad = st.audio(audio_bytes, format="audio/mp3")
else:
    gospel.empty()
    content.empty()
    story.empty()
    image.empty()
    reflection.empty()
    ad.empty()
st.button("Reset", type="primary")
